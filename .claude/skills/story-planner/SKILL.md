---
name: story-planner
description: Create user story documents with task breakdown, conventions, and progress tracking from existing bounded-context documents. This skill reads from bounded-contexts + design sources + existing code. PREREQUISITE: docs/technical-specs/{bc}.md (technical spec) must exist (generate with technical-spec-generator skill first). INPUT: Wave name (e.g., "auth-wave", "password-reset") or project description. The skill locates bounded-context documents (technical specification) and generates user story documents (defines HOW with task breakdown, execution plan, quality standards, and BDD scenarios). Use when starting a NEW development wave or adding features to an EXISTING application.
---

# Story Planner

## Overview

Create planning materials for implementation. This skill generates:
1. **User story documents** (`development/{wave}/phase-*-story-*.md`) - Task breakdown organized by execution flow (TDD: Tests → Backend → Frontend → Fix Tests)
2. **Conventions document** (`development/{wave}/development-conventions.md`) - Shared principles and patterns
3. **Progress tracking** (`development/{wave}/development-progress.md`) - Status summary

**PREREQUISITE**: `docs/technical-specs/{bc}.md (technical spec)` must exist (use `technical-spec-generator` skill first).

**INPUT**: Wave name (e.g., `auth-wave`, `password-reset`) or project description. The skill locates `docs/technical-specs/{bc}.md (technical spec)` to read technical specifications.

---

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `wave_name` | optional | Wave name (e.g., `auth-wave`, `password-reset`). If matches a BC name, uses `docs/technical-specs/{bc}.md (technical spec)`. If a composite wave, reads multiple technical spec documents. |
| `project_description` | optional | Description of the wave (used if wave_name not provided). Skill extracts/infers wave name from description. |

> **Default Behavior**: If invoked without parameters, asks user for wave name or project description.

---

## BC Name Resolution

| Input | Resolves To | Bounded Context Location |
|-------|-------------|---------------------------|
| `authentication` | Wave for one BC | `docs/technical-specs/authentication.md` |
| `auth-wave` | Wave for multiple BCs | Multiple `docs/technical-specs/*.md` files |
| `password reset` | `authentication` (maps to BC) | `docs/technical-specs/authentication.md` |
| (missing) | Prompt user | - |

---

**Key Principle**: **Separation of concerns (Technical Specification vs Implementation Planning)**:
- `docs/technical-specs/{bc}.md (technical spec)` = Defines **WHAT** (BC design + pseudo-code flows + API contracts + data model) - **Generated by technical-spec-generator skill**
- `phase-{NN}-story-{MM}-{title}.md` = Defines **HOW** (BDD scenarios + task breakdown + execution plan + quality standards)
- `development-conventions.md` = Shared principles, patterns, tech stack (lean, ~200 lines)
- `development-progress.md` = Summary tracking across all stories

**Key Principle**: **Prerequisite bounded-context document** - The BC document must exist before running this skill. The story-planner reads the existing BC document to create story documents with BDD scenarios.

**Key Principle**: **Wave vs Bounded Context**:
- A **technical specification** is a DDD tactical pattern (e.g., "Authentication", "Data Analysis") with spec in `docs/technical-specs/`
- A **wave** is a development initiative that implements one or multiple technical specifications
- Wave name may match a BC name (single-BC wave) or be composite (multi-BC wave)

**Key Principle**: **Pseudo-code vs BDD Scenarios**:
- **Pseudo-code** (in technical spec documents) = Internal algorithm logic (PHASE 1 → 2 → 3 format) - defines HOW system works internally
- **BDD scenarios** (in story documents) = Observable behavior (Given/When/Then format) - defines WHAT users experience

**Key Principle**: **Task Definition ≠ Prescriptive Implementation**:
- Task definitions describe **what needs to be done** (e.g., "Implement JWT authentication endpoint")
- Prescriptive implementation shows **exactly how to do it** (e.g., `jwt.sign(payload, secret)` - source code)
- User story documents contain task definitions organized by execution flow; developer agents write the actual code

**Key Principle**: **TDD Philosophy** - Tasks are organized by execution flow following Test-Driven Development: Tests (Red phase) → Implementation (Green phase) → Refactor.

**Key Principle**: **Preview before generation**. Always show the proposed plan (phases and stories) to the user for approval before creating any documents. This prevents wasted effort on incorrect plans.

**Key Principle**: **Safety check for existing work**. Always check if plan documents already exist before creating new ones. Offer backup, remove, or rename options to prevent accidental data loss.

---

## Workflow

**PREREQUISITE**: Run `technical-spec-generator` skill first to create `docs/technical-specs/{bc}.md (technical spec)` (combined tactical + technical specification).

**INPUT**: Wave name (e.g., `auth-wave`, `password-reset`) or project description.

```
                   User Input (wave_name or description)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ RESOLVE WAVE NAME                                               │
│                                                                 │
│ - If wave_name provided → use directly                         │
│ - If description provided → extract/confirm wave name          │
│ - If missing → ask user for wave name                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ PREREQUISITE CHECK                                             │
│                                                                 │
│ Verify bounded-context document(s) exist:                      │
│ - Single wave: Check docs/technical-specs/{bc}.md (technical spec) exists     │
│ - Multi wave: Check relevant docs/technical-specs/*.md files │
│ - If missing → prompt to run technical-spec-generator first    │
│   Example: "Please run: /skill technical-spec-generator {bc}"   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 1: Preliminary Scope Confirmation                          │
│                                                                 │
│ Ask basic scope questions BEFORE deep investigation:          │
│ - What BC area?                                              │
│ - New feature or modify existing?                              │
│ - Approximate scope? (Small/Medium/Large)                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 2: READ Design Documents (3 Sources)                      │
│                                                                 │
│ Use Glob to dynamically discover files:                        │
│ Source 0: docs/technical-specs/{bc}.md (technical spec) (BC + technical spec) │
│ Source 1: docs/application-design/*.md (strategic design)      │
│ Source 2: docs/ui-pages/*.html (UI prototypes)                │
│ Source 3: [Brownfield] Existing code (gap analysis)            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 3: INTERACTIVE SESSION with User                         │
│ - Present understanding summary from all sources               │
│ - [Brownfield] Show gap analysis                               │
│ - Ask clarifying questions using AskUserQuestion              │
│ - Discuss options and trade-offs                               │
│ - Get user decisions on ambiguous items                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 4: Determine Wave Name & Create Directory                │
│ - Descriptive identifier in kebab-case                         │
│ - CHECK: Existing plan documents?                             │
│ - ASK: Backup, remove, or rename?                             │
│ - Create development/{wave}/ directory                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 5: Determine Phase Count and User Stories                │
│ - Read bounded-context document to understand domain flows     │
│ - [Greenfield] Plan all features from BC document             │
│ - [Brownfield] Plan gaps/missing features only                │
│ - Simple: 1-2 phases → Medium: 3-4 → Complex: 5+             │
│ - BREAK DOWN PHASES INTO USER STORIES                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 6: PREVIEW & APPROVAL                                   │
│ - Show project type (GREENFIELD/BROWNFIELD)                    │
│ - [Brownfield] Show gap analysis summary                       │
│ - Show proposed plan: phases and stories                       │
│ - ASK: Generate, Adjust, or Cancel?                           │
│ - Wait for user approval before creating story documents       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 7: Create User Story Documents                           │
│ - One file per story: phase-{NN}-story-{MM}-{title}.md        │
│ - Each story: As/I want/So that + acceptance criteria         │
│ - BDD scenarios: Given/When/Then (derived from BC flows)       │
│ - Tasks organized by execution flow:                          │
│   1. Testing (TDD - Write First)                              │
│   2. Backend Implementation                                   │
│   3. Frontend Implementation                                  │
│   4. Testing (Make Tests Pass)                                │
│   5. Refactor (Optional)                                      │
│ - Technical Reference: Points to bounded-context sections      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 8: Create development-conventions.md                    │
│ - Shared principles, patterns, tech stack                    │
│ - Extracted from docs/application-design/conventions.md        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ STEP 9: Create development-progress.md                       │
│ - Story summary tables per phase                              │
│ - Status tracking (not detailed tasks)                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                 Output: Stories ready for development
```

---

## Step 1: Preliminary Scope Confirmation

**PURPOSE**: Ask basic scope questions BEFORE deep investigation to enable targeted reading.

### Why This Step Matters

Without preliminary scope confirmation, the skill would:
- Read ALL design documents (even irrelevant ones)
- Scan entire codebase (even unrelated areas)
- Potentially investigate areas the user doesn't care about

With scope confirmation first:
- Investigation can be **targeted** to relevant technical specifications
- Focus reading on applicable feature areas
- Reduce investigation time
- Ask better questions in the deep-dive session (Step 3: Interactive Session)

### Questions to Ask

Use `AskUserQuestion` to gather preliminary scope:

```python
AskUserQuestion(questions=[{
    "question": "What feature area does this feature involve?",
    "header": "Feature Area",
    "options": [
        {"label": "Authentication / Authorization", "description": "User accounts, login, OAuth, permissions"},
        {"label": "Data Analysis / Processing", "description": "SPSS upload, indicator generation, analysis execution"},
        {"label": "Chat / AI Features", "description": "Chat interface, AI integration, conversation management"},
        {"label": "Export / Reporting", "description": "Results export, report generation, file downloads"},
        {"label": "UI / UX Improvements", "description": "Interface redesign, component updates, styling"},
        {"label": "Infrastructure / DevOps", "description": "Deployment, monitoring, migrations, refactoring"}
    ],
    "multiSelect": False
}, {
    "question": "Is this a new feature or modifying existing functionality?",
    "header": "Type",
    "options": [
        {"label": "New feature", "description": "Building something from scratch"},
        {"label": "Modify existing", "description": "Changing or enhancing existing functionality"},
        {"label": "Bug fixes only", "description": "Fixing issues without adding features"},
        {"label": "Refactor / Migration", "description": "Restructuring code or migrating technologies"}
    ],
    "multiSelect": False
}])
```

### Adaptive Investigation Scope

Based on user's answers, **focus investigation** in Step 2:

| User Answer | Focus Investigation On |
|-------------|----------------------|
| Authentication | `docs/technical-specs/*auth*.md`, `docs/ui-pages/*login*.html`, existing auth code |
| Data Analysis | `docs/technical-specs/*analysis*.md`, `docs/ui-pages/*analysis*.html`, dflib/ |
| Chat / AI | `docs/technical-specs/*chat*.md`, `docs/ui-pages/*chat*.html`, AI integration code |
| Export | `docs/technical-specs/*export*.md`, export endpoints, file handling code |

### Greenfield vs Brownfield Detection

Also in this step, quickly detect feature type:

```bash
# Quick check for existing implementation
Glob: web/backend/app/**/*.py
Glob: web/frontend/src/**/*.tsx
```

If files exist → **BROWNFIELD** (include gap analysis)
If no files → **GREENFIELD** (new feature)

### Output of Step 1

After Step 1, you should have:
- **Feature area** identified (which technical specifications are relevant)
- **Project type** detected (GREENFIELD vs BROWNFIELD)
- **Approximate scope** (Small/Medium/Large - affects phase count)
- **Targeted reading list** (which docs to prioritize in Step 2)

Proceed to **Step 2: Read Design Documents** with this scope information.

---

## Step 2: Read Design Documents

**CRITICAL**: Read and understand all materials from **FOUR sources** (for brownfield) or **THREE sources** (for greenfield).

**NOTE**: Based on preliminary scope from Step 1, you can **prioritize** reading certain documents, but still do a comprehensive review to ensure nothing is missed.

**IMPORTANT**: Use `Glob` to dynamically discover files. Do NOT rely on fixed lists - files may be added, removed, or renamed.

### Feature Type Detection

First, detect whether this is a **greenfield** (new) or **brownfield** (existing) feature:

```bash
# Check for existing implementation
Glob: web/backend/app/**/*.py
Glob: web/frontend/src/**/*.tsx

if files exist:
    PROJECT_TYPE = "BROWNFIELD"  # Existing codebase
    SOURCES = 4  # Include existing code analysis
else:
    PROJECT_TYPE = "GREENFIELD"  # New feature
    SOURCES = 3  # Design documents only
```

**Report feature type to user in Step 3 (Interactive Session).**

---

### Source 0: Bounded Context Document (PREREQUISITE)

**Verify bounded-context document exists:**

```bash
Glob: docs/technical-specs/*.md
```

The `docs/technical-specs/{bc}.md (technical spec)` must exist before running story-planner. This document is generated by the `technical-spec-generator` skill and contains combined tactical + technical design.

**If bounded-context document is missing**, prompt the user:
```
Bounded context document not found: docs/technical-specs/{bc}.md (technical spec)

Please run the technical-spec-generator skill first:
/skill technical-spec-generator {bc-name}

Then re-run story-planner.
```

**What to Extract from Bounded Context Document:**

| Section | What to Extract |
|---------|-----------------|
| BC Overview | BC purpose, responsibilities, domain scope |
| Domain Model | Aggregates, entities, value objects that inform story breakdown |
| Domain Flows (Pseudo-code) | Business logic sequences that inform BDD scenarios |
| API Contracts | Endpoints that need implementation (group into stories) |
| Data Model | Tables and relationships that inform backend stories |
| Repository Contracts | Interfaces that need implementation |
| BC Relationships | Story ordering based on upstream/downstream dependencies |

**How Bounded Context Document Informs Planning:**

| Planning Aspect | Information from BC Document |
|-----------------|-------------------------------|
| Story scope | Domain flows map to user stories |
| Story dependencies | BC relationships inform story order |
| BDD scenarios | Pseudo-code flows are converted to Given/When/Then |
| Testing scope | Testing requirements inform story testing criteria |
| Technical reference | Each story references relevant BC sections |

---

### Source 1: Application Design Documents (Backend/System)

**Dynamically discover and read all markdown files:**

```bash
Glob: docs/application-design/*.md
```

Read each file found. These documents define the backend, API, database, and system architecture.

**Examples of documents you may find** (this is not a fixed list - actual files vary):

| Document Type | Typical Purpose |
|---------------|-----------------|
| `*-architecture.md` | System design, DDD structure, components |
| `database-schema.md` | Tables, relationships, migrations |
| `api-contract.md` | Endpoints, request/response formats |
| `conventions.md` | Code style, naming, patterns |
| `project-structure.md` | Directory organization |
| `*-auth.md` | Authentication, authorization, RBAC |
| `*-pipeline.md` | Data processing workflows |
| `*-integration.md` | External system integrations |

---

### Source 2: UI Pages (Frontend/Interface Design)

**Dynamically discover and read all HTML prototype files:**

```bash
Glob: docs/ui-pages/*.html
```

Read each file found. These HTML prototypes define the frontend UI components, layouts, and interface design.

**Examples of prototypes you may find** (this is not a fixed list - actual files vary):

| UI Component Type | Typical Purpose |
|-------------------|-----------------|
| `*-page.html` | Full page layouts (login, overview, settings) |
| `*-list.html` | List/table views (datasets, indicators) |
| `*-result.html` | Results display pages |
| `*-builder.html` | Creation/editing interfaces |
| `*-gallery.html` | Grid/card layouts for browsing |
| `*-modal.html` | Modal dialogs and popups |
| `*-component.html` | Reusable UI components (sidebar, header) |
| `empty-*.html` | Empty state placeholders |

---

### Source 1: Application Design Documents (Strategic Design)

**Dynamically discover and read all markdown files:**

```bash
Glob: docs/application-design/*.md
```

Read each file found. These documents define the strategic design (DDD structure, system architecture, conventions).

**What to Extract from Application Design:**

| Section | What to Extract |
|---------|-----------------|
| System Architecture | Overall system design, DDD structure |
| Bounded Contexts List | All BCs and their purposes |
| Technology Stack | Backend, frontend, database technologies |
| Conventions | Coding standards, patterns, naming |
| Security Principles | Cross-cutting security requirements |

**How Application Design Informs Planning:**

| Planning Aspect | Information from App Design |
|-----------------|----------------------------|
| Phase scope | Which BCs to implement in which phase |
| Tech stack | Backend/frontend frameworks to use |
| Coding standards | Naming, patterns, formatting |
| Security | Cross-cutting security requirements |

---

### Source 2: UI Pages (Frontend/Interface Design)

**Dynamically discover and read all HTML prototype files:**

```bash
Glob: docs/ui-pages/*.html
```

Read each file found. These HTML prototypes define the frontend UI components, layouts, and interface design.

### Source 3: Existing Code (BROWNFIELD ONLY)

**For brownfield features**, analyze existing implementation to identify what's already built.

**Dynamically scan existing code:**

```bash
# Backend - scan for implemented features
Glob: web/backend/app/api/**/*.py     # API endpoints
Glob: web/backend/app/domain/**/*.py  # Domain models
Glob: web/backend/app/infrastructure/**/*.py  # Repository implementations

# Frontend - scan for implemented features
Glob: web/frontend/src/routes/**/*.tsx     # Routes/pages
Glob: web/frontend/src/components/**/*.tsx # Components
Glob: web/frontend/src/stores/**/*.ts      # State management
```

**What to Extract from Existing Code:**

| Area | What to Identify | How to Detect |
|------|------------------|--------------|
| **Backend APIs** | Which endpoints exist | Scan `api/` for router files, list all routes |
| **Domain models** | Which aggregates/entities | Scan `domain/` for model classes |
| **Repositories** | Which repositories implemented | Scan `infrastructure/` for repository implementations |
| **Frontend routes** | Which pages exist | Scan `routes/` for route files |
| **Components** | Which UI components built | Scan `components/` for component files |
| **Tests** | Test coverage | Scan `tests/` for test files |

**Gap Analysis Process:**

1. **List planned features** from design documents:
   - API endpoints from `api-contract.md` or technical spec documents
   - User stories from requirements
   - UI components from `ui-pages/` prototypes

2. **List implemented features** from existing code scan

3. **Compare: Planned vs Implemented**

4. **Identify gaps**:
   - **Missing user stories** (feature planned but not implemented)
   - **Partial implementations** (feature started but incomplete)
   - **Missing tests** (feature implemented but not tested)
   - **Missing UI** (backend exists but frontend not built)

5. **Focus planning on gaps only** - Don't plan what's already complete

**Example Gap Analysis:**

| Planned Feature | Status | Notes |
|----------------|--------|-------|
| User registration | ✅ Implemented | API + UI complete, tests pass |
| Email verification | ⚠️ Partial | API exists, UI not built |
| OAuth login | ❌ Missing | Not implemented |
| Password reset | ❌ Missing | Not implemented |

**For this example, only plan stories for:**
- Email verification UI completion
- OAuth login (full story)
- Password reset (full story)

**Skip planning for:**
- User registration (already complete)

---

### Understanding Checklist

After reading from **all sources**, ensure you understand:

**From Application Design (Source 0 - Strategic Design):**
- [ ] System architecture (frontend, backend, database, deployment)
- [ ] Bounded contexts list and context mapping
- [ ] Domain boundaries and relationships
- [ ] Existing conventions (naming, patterns, testing)
- [ ] Project structure (where code lives)
- [ ] Key integrations (external services, third-party APIs)

**From UI Pages (Source 1 - UI Prototypes):**
- [ ] Layout patterns (sidebar, topbar, main content area)
- [ ] Component library (buttons, forms, modals, tables)
- [ ] Color scheme and styling (CSS classes used)
- [ ] Navigation structure (routes, menu items)
- [ ] Data display patterns (tables, cards, grids)
- [ ] Form patterns (input types, validation, layouts)
- [ ] Interactive elements (modals, dropdowns, drag-drop)

**From Bounded Context Documents (Source 0 - Combined Tactical + Technical):**
- [ ] Aggregates and their roots for each BC
- [ ] Entities and value objects per BC
- [ ] Repository contracts and interfaces
- [ ] API surface (endpoints) per BC
- [ ] Domain services per BC
- [ ] Data ownership (tables per BC)
- [ ] Relationships between BCs (upstream/downstream)
- [ ] Domain events and their consumers

**From Existing Code (Source 2 - Brownfield Only):**
- [ ] Which features are already implemented
- [ ] Which features are partially implemented
- [ ] Which features are completely missing
- [ ] Test coverage status for implemented features
- [ ] Technical debt or refactoring needs
- [ ] Gaps between design and implementation

### Create Understanding Summary

Before proceeding to Step 3 (Interactive Session), create an internal summary of:

1. **What the system does** (core purpose and capabilities)
2. **How it's structured** (architecture, layers, technical specifications)
3. **Tactical design details** (aggregates, entities, repositories per BC from bounded-context docs)
4. **What already exists** (implemented features, design decisions)
5. **What's missing** (gaps - brownfield only)
6. **What needs clarification** (gaps, ambiguities, user preferences)

This summary will be presented to the user in Step 3.

**For brownfield features, include:**
- Project type detection result (GREENFIELD vs BROWNFIELD)
- Existing features summary (what's already built)
- Gap analysis (what's missing or incomplete)
- Recommended focus areas for new stories

---

## Step 2.5: Present Planning Recommendations (BROWNFIELD ONLY)

**NOTE**: This step is specifically for brownfield features. After completing the gap analysis in Step 2, present planning recommendations to help the user choose the scope of work.

### Present Recommendations Option

Use `AskUserQuestion` to present planning options:

```python
AskUserQuestion(questions=[{
    "question": "What scope of planning would you like?",
    "header": "Planning Scope",
    "options": [
        {
            "label": "Complete all remaining features",
            "description": "Plan to finish the entire application - implement all missing/partial features to reach production-ready state"
        },
        {
            "label": "Focus on specific feature area",
            "description": "Plan for a specific technical specification or feature set (e.g., analysis features, chat UI, export)"
        },
        {
            "label": "Address specific migration/refactor",
            "description": "Plan for a specific migration or refactoring task (e.g., R subprocess migration, DB schema update)"
        },
        {
            "label": "Testing & polish focus",
            "description": "Plan comprehensive testing, bug fixes, and polish for existing features"
        }
    ],
    "multiSelect": False
}])
```

### Option Details

| Option | When to Use | Example Scope |
|--------|------------|---------------|
| **Complete all remaining features** | User wants to finish the entire application | All missing features across all technical specifications |
| **Focus on specific feature area** | User wants to prioritize one area | Only analysis features, only chat UI, only export |
| **Address specific migration/refactor** | Technical migration or refactoring needed | R subprocess migration, API refactor, DB migration |
| **Testing & polish focus** | Features exist but need quality improvement | Unit tests, integration tests, E2E tests, bug fixes |

### After User Selection

- **Complete all remaining features**: Proceed with comprehensive gap analysis across ALL technical specifications
- **Focus on specific feature area**: Ask which technical specification/feature area to focus on
- **Address specific migration/refactor**: Ask for specific migration details or reference existing task docs
- **Testing & polish focus**: Scan existing code for test coverage gaps and known issues

---

## Step 3: Interactive Session with User

After reading and understanding the bounded-contexts and design documents, engage in a structured dialogue with the user to confirm understanding and make decisions.

### 3.1 Present Understanding Summary

Start by presenting your understanding of the feature based on **all sources**:

```
Based on the design documents, I understand:

**Feature Type**: [GREENFIELD / BROWNFIELD]
[If BROWNFIELD: Detected existing implementation in web/backend/ and/or web/frontend/]

**System Purpose**: [brief description]

**Architecture**: [frontend/backend/database stack]

**Strategic Design** (from docs/application-design/*.md):
- Bounded contexts: [list of BCs]
- Context mapping: [how BCs relate]
- System topology: [overall structure]

**Tactical Design** (from docs/technical-specs/*.md):
- Per BC aggregates, entities, repositories
- API surface per BC
- BC relationships and dependencies

**Frontend Design** (from docs/ui-pages/*.html):
- UI components, layout patterns, navigation

**Existing Design**: [key design decisions already made]

**[If BROWNFIELD] Existing Implementation** (from code analysis):
- Already implemented: [list of features]
- Partially implemented: [list of features]
- Missing: [list of features]
- Gap analysis: [what needs to be built]

**Project Scope**: [what needs to be implemented]
[If BROWNFIELD: Focus on missing/incomplete features only]

Is my understanding correct? Any corrections or additions?
```

### 3.2 Ask Clarifying Questions

Use the `AskUserQuestion` tool to ask questions about unclear items or decisions needed. Group questions logically.

#### Common Clarification Topics

| Topic | Questions to Ask | Why It Matters |
|-------|------------------|----------------|
| **Scope boundaries** | "Should this include [feature X] or focus only on [Y]?" | Determines phase scope |
| **Priority** | "Which features are critical vs. nice-to-have?" | Affects phase ordering |
| **Technology choices** | "Prefer [option A] or [option B] for [component]?" | Technical decisions |
| **Integration depth** | "Full integration with [system] or phased approach?" | Affects complexity |
| **Testing approach** | "Comprehensive E2E tests or focused integration tests?" | Testing effort |
| **Timeline** | "Any deadline constraints or phase completion targets?" | Phase sizing |
| **[Brownfield] Refactoring** | "Should we refactor existing code or build new features only?" | Affects planning scope |
| **[Brownfield] Gap priority** | "Focus on missing features or improve partial implementations first?" | Affects story order |
| **[Brownfield] Technical debt** | "Any existing technical debt to address while adding features?" | May need separate stories |

#### Example Question Session

```python
AskUserQuestion(questions=[
    {
        "question": "What is the primary focus for this development wave?",
        "header": "Focus",
        "options": [
            {"label": "New feature", "description": "Build a new capability from scratch"},
            {"label": "Refactor existing", "description": "Improve/restructure existing code"},
            {"label": "Integration", "description": "Connect to external system/service"},
            {"label": "Bug fixes", "description": "Fix specific issues"}
        ],
        "multiSelect": False
    },
    {
        "question": "Which testing approach should we prioritize?",
        "header": "Testing",
        "options": [
            {"label": "Comprehensive", "description": "Full unit + integration + E2E coverage"},
            {"label": "Focused", "description": "Unit tests for critical paths only"},
            {"label": "Phase 1 only", "description": "Tests in first phase, defer to later"}
        ],
        "multiSelect": False
    }
])
```

### 3.3 Discuss Options and Trade-offs

For decisions with multiple valid approaches, present options and let the user choose:

```
For [component/feature], I see two approaches:

**Option A: [Approach name]**
- Pros: [benefit 1], [benefit 2]
- Cons: [downside 1], [downside 2]
- Best for: [use case]

**Option B: [Approach name]**
- Pros: [benefit 1], [benefit 2]
- Cons: [downside 1], [downside 2]
- Best for: [use case]

Which approach do you prefer?
```

### 3.4 Confirm Before Proceeding

After Q&A, summarize the decisions and get confirmation:

```
**Summary of Decisions:**
- Project name: {name}
- Phase count: {number}
- Primary focus: {focus}
- Tech stack: {confirmed stack}
- Testing approach: {chosen approach}

Proceed to create planning documents with these decisions?
```

Only proceed to Step 4 after user confirmation.

---

## Step 4: Determine Wave Name & Create Directory

Every wave needs a descriptive name for its subdirectory.

### Wave Naming Guidelines

| Guideline | Description | Example |
|-----------|-------------|---------|
| **Descriptive** | Clearly indicates what the wave does | `user-auth-system`, `data-export-feature` |
| **kebab-case** | Use lowercase with hyphens | `oauth-integration`, not `OAuthIntegration` |
| **Concise** | Short but meaningful | `csv-export`, not `csv-file-export-functionality` |
| **Unique** | Don't conflict with existing waves | Check `ls development/` first |

### Examples

| User Request | Suggested Wave Name |
|--------------|---------------------|
| "Build a user authentication system with OAuth" | `user-auth-oauth` |
| "Create a data export feature for CSV and Excel" | `data-export-feature` |
| "Add a real-time chat using WebSockets" | `websocket-chat` |
| "Implement a payment gateway integration" | `payment-gateway` |

### Create the Project Directory

```bash
# Create the wave subdirectory
mkdir -p "development/{wave-name}"
```

**Example:**
```bash
mkdir -p "development/user-auth-oauth"
```

### Check for Existing Plan Documents

**CRITICAL**: Before creating the wave directory, check if plan documents already exist.

#### Step 4.1: Check Development Directory

```bash
# List existing waves
ls -la development/
```

#### Step 4.2: If Project Directory Exists

If `development/{wave-name}/` already exists, use `AskUserQuestion` to present options:

```python
AskUserQuestion(questions=[{
    "question": f"Project '{project-name}' already exists in development/. What would you like to do?",
    "header": "Existing Project",
    "options": [
        {
            "label": "Create backup",
            "description": "Move existing to backup (development/{wave-name}/ → development/{wave-name}-backup-{timestamp}/)"
        },
        {
            "label": "Remove existing",
            "description": "Delete existing directory and create fresh plan documents"
        },
        {
            "label": "Use different name",
            "description": "Keep existing, create new plan with different wave name"
        }
    ],
    "multiSelect": False
}])
```

#### Step 4.3: Handle User's Choice

| User Choice | Action |
|-------------|--------|
| **Create backup** | `mv development/{name} development/{name}-backup-{timestamp}` |
| **Remove existing** | `rm -rf development/{name}` |
| **Use different name** | Return to wave naming step, choose new name |

#### Step 4.4: Create Fresh Directory

After handling existing files (or if none exist):

```bash
mkdir -p "development/{wave-name}"
```

---

## Step 5: Determine Phase Count and Structure

Based on feature analysis, intelligently determine how many phases are needed.

### Phase Planning Guidelines

| Project Complexity | Phase Count | Phase Structure |
|--------------------|-------------|-----------------|
| **Simple** (1-2 weeks, single feature) | 1-2 phases | Phase 1: Foundation + Feature → Phase 2: Polish |
| **Medium** (1-3 months, multiple features) | 3-4 phases | Phase 1: Setup → Phase 2: Core → Phase 3: Advanced → Phase 4: Testing/Polish |
| **Complex** (3+ months, many integrations) | 5+ phases | Phase 1: Foundation → Phase 2: Core Domain → Phase 3: Advanced Features → Phase 4: Integrations → Phase 5: Testing → Phase 6: Deployment |

### Phase Naming Convention

Each phase should have a descriptive name:
- `phase-01-story-01-{title}.md`
- `phase-01-story-02-{title}.md`
- `phase-02-story-01-{title}.md`
- etc.

**Format**: `phase-{NN}-story-{MM}-{kebab-case-title}.md`

**Note**: Phases are logical groupings for organizing stories. Each story is a self-contained document.

---

## Step 6: Preview & Approval

**CRITICAL**: Before creating any story documents, present the proposed plan to the user for approval.

This prevents generating incorrect or unwanted documents.

### Present the Proposed Plan

Show a structured summary of:

1. **Project type** (GREENFIELD vs BROWNFIELD)
2. **Project name** and directory location
3. **[Brownfield] Gap analysis** - what's missing/partial
4. **Phase breakdown** with descriptive names
5. **User story list** with file names for each
6. **Total counts** (phases, stories)

### Example Preview (Greenfield)

```markdown
## Proposed Plan: user-auth-oauth

**Feature Type**: GREENFIELD (new feature)
**Location**: `development/user-auth-oauth/`

### Phase 1: Foundation (3 user stories)

| Story File | Title | User Story |
|------------|-------|------------|
| `phase-01-story-01-user-registration.md` | User Registration | As a user, I can register... |
| `phase-01-story-02-email-verification.md` | Email Verification | As a user, I can verify email... |
| `phase-01-story-03-user-login.md` | User Login | As a user, I can login... |

### Phase 2: OAuth Integration (2 user stories)

| Story File | Title | User Story |
|------------|-------|------------|
| `phase-02-story-01-oauth-google.md` | Google OAuth | As a user, I can login with Google... |
| `phase-02-story-02-oauth-github.md` | GitHub OAuth | As a user, I can login with GitHub... |

---

**Summary**: 2 phases, 5 user stories
**Directory**: `development/user-auth-oauth/`
**Files to create**:
- phase-01-story-01-user-registration.md
- phase-01-story-02-email-verification.md
- phase-01-story-03-user-login.md
- phase-02-story-01-oauth-google.md
- phase-02-story-02-oauth-github.md
- development-conventions.md
- development-progress.md
```

### Example Preview (Brownfield)

```markdown
## Proposed Plan: data-analysis-enhancement

**Feature Type**: BROWNFIELD (existing codebase detected)
**Location**: `development/data-analysis-enhancement/`

### Gap Analysis

| Feature | Status | Notes |
|---------|--------|-------|
| User authentication | ✅ Complete | Fully implemented with tests |
| Dataset upload | ⚠️ Partial | Backend exists, UI missing |
| Indicator generation | ❌ Missing | Not implemented |
| Analysis execution | ❌ Missing | Not implemented |
| Results export | ❌ Missing | Not implemented |

**Planning focus**: 4 stories to complete partial features + add missing features

### Phase 1: Complete Partial Features (2 user stories)

| Story File | Title | User Story |
|------------|-------|------------|
| `phase-01-story-01-dataset-upload-ui.md` | Dataset Upload UI | As a user, I can upload SPSS files via UI... |
| `phase-01-story-02-indicator-generation.md` | Indicator Generation | As an analyst, I can generate indicators... |

### Phase 2: New Features (2 user stories)

| Story File | Title | User Story |
|------------|-------|------------|
| `phase-02-story-01-analysis-execution.md` | Analysis Execution | As an analyst, I can run analyses... |
| `phase-02-story-02-results-export.md` | Results Export | As a user, I can export results... |

---

**Summary**: 2 phases, 4 user stories (focusing on gaps only)
**Skipped**: User authentication (already complete)

**Files to create**:
- phase-01-story-01-dataset-upload-ui.md
- phase-01-story-02-indicator-generation.md
- phase-02-story-01-analysis-execution.md
- phase-02-story-02-results-export.md
- development-conventions.md
- development-progress.md
```

### Ask for Approval

After presenting the plan, use `AskUserQuestion`:

```python
AskUserQuestion(questions=[{
    "question": f"Proposed plan for '{project_name}': {phase_count} phases, {story_count} stories. Proceed?",
    "header": "Approval",
    "options": [
        {
            "label": "Generate",
            "description": "Create all story documents, development-conventions.md, and development-progress.md"
        },
        {
            "label": "Adjust",
            "description": "Modify the plan (add/remove stories, rename phases, etc.)"
        },
        {
            "label": "Cancel",
            "description": "Cancel planning without creating documents"
        }
    ],
    "multiSelect": False
}])
```

### Handle User Response

| User Choice | Action |
|-------------|--------|
| **Generate** | Proceed to Step 7: Create User Story Documents |
| **Adjust** | Return to Step 3/Step 5, revise plan, then re-preview |
| **Cancel** | Stop skill execution, no documents created |

### When Adjusting

If user chooses "Adjust", ask follow-up questions:

| Question | Options |
|----------|---------|
| "What would you like to adjust?" | Add story, Remove story, Rename phase, Change story count |
| "Which phase needs adjustment?" | Phase 1, Phase 2, etc. |
| "What's the change?" | [Free text input] |

After adjustments, **re-run Step 6** to show updated plan and ask for approval again.

---

## Step 7: Create User Story Documents

**Only after user approval from Step 6**

For each user story, create a document with task breakdown organized by execution flow.

**CRITICAL: Task Definition Principle**

Story documents define **HOW** (task breakdown, execution plan, quality standards):

| Document | Defines | Content |
|----------|---------|---------|
| **Feature Spec** | **WHAT** | Design, specification, what the final thing will look like |
| **User Story Document** | **HOW** | Task definitions, execution plan, quality standards |
| **Developer Agent** | **Implementation** | Source code, scripts, prescriptive details |

**Task Definition ≠ Prescriptive Implementation**:

| Aspect | Task Definition (✅ Include) | Prescriptive Implementation (❌ Don't Include) |
|--------|---------------------------|---------------------------------------------|
| **Backend** | "Implement JWT authentication endpoint" | `jwt.sign(payload, secret)` (source code) |
| **Database** | "Create users table with email, password_hash columns" | `CREATE TABLE users (...)` (SQL script) |
| **Frontend** | "Build login form component with email/password fields" | `<input type="email" />` (JSX code) |
| **Testing** | "Write unit tests for password hashing" | `def test_hash_password(): ...` (test code) |

**Rule**: User story documents describe **what tasks** need doing. Developer agents write **the actual code**.

### Story Document Structure

See **[`references/story-document-template.md`](references/story-document-template.md)** for the complete template.

**File format**: `phase-{NN}-story-{MM}-{kebab-case-title}.md`

**Document structure**:
```markdown
# User Story {phase}.{story}: {Story Title}

**Phase**: Phase {N}: {Phase Name}
**Priority**: Must Have / Should Have / Nice to Have

## User Story
**As a** {role}... **I want** {feature}... **So that** {value}...

## Acceptance Criteria
- [ ] {Criterion 1}
- [ ] {Criterion 2}
- [ ] {Criterion 3}
- [ ] All tests passing (unit, integration, E2E)

## BDD Scenarios
**Feature Spec Reference**: See `bounded-contexts/{feature}.md` Section {X} for complete BDD scenarios

### Story-Specific Scenarios
#### Scenario 1: {Success Case}
Given {precondition}... When {action}... Then {outcome}...

#### Scenario 2: {Error Case}
Given {precondition}... When {action}... Then {error outcome}...

## Tasks (Organized by Execution Flow)

### 1. Testing (TDD - Write First)
| Task | Status | Notes |
|------|--------|-------|
| Write unit tests for backend domain | ⚪ | Test entities, value objects, business rules |
| Write unit tests for frontend components | ⚪ | Test business logic, state management |
| Write integration tests for API endpoints | ⚪ | Happy path + error cases |
| Write E2E tests for critical journeys | ⚪ | Core workflows |

### 2. Backend Implementation
| Task | Status | Notes |
|------|--------|-------|
| Create database schema and migrations | ⚪ | See bounded-contexts data model |
| Implement domain models and entities | ⚪ | |
| Implement API endpoints | ⚪ | See bounded-contexts API contracts |
| Implement business logic services | ⚪ | |

### 3. Frontend Implementation
| Task | Status | Notes |
|------|--------|-------|
| Create/update state management | ⚪ | |
| Build UI components | ⚪ | |
| Create pages/routes | ⚪ | |
| Integrate with backend API | ⚪ | |

### 4. Testing (Make Tests Pass)
| Task | Status | Notes |
|------|--------|-------|
| Fix failing unit tests (backend) | ⚪ | |
| Fix failing unit tests (frontend) | ⚪ | |
| Fix failing integration tests | ⚪ | |
| Fix failing E2E tests | ⚪ | |

### 5. Refactor (Optional)
| Task | Status | Notes |
|------|--------|-------|
| Refactor for code quality | ⚪ | |

## Technical Reference
**Feature Spec**: `bounded-contexts/{feature}.md`
**Relevant Sections**: 1.{X}, 2.{X}, 3, 4, 5, 6

## Dependencies
## UI References
## Design References
## Story Status
```

### User Story Creation Guidelines

| Aspect | Guidelines |
|--------|------------|
| **Format** | "As a {role}, I want {feature}, so that {value}" |
| **Role** | Specific user type (admin, analyst, end-user) |
| **Feature** | Specific functionality being delivered |
| **Value** | Business benefit or user outcome |
| **Acceptance Criteria** | 2-5 specific, testable conditions |
| **BDD Scenarios** | 3-6 scenarios covering success paths, error cases, edge cases |
| **Size** | 1-2 weeks of work per story (break down large stories) |
| **File name** | `phase-{NN}-story-{MM}-{kebab-case-title}.md` |

### BDD Scenario Guidelines

**BDD Scenarios live in BOTH places**:

| Location | Purpose | Content |
|----------|---------|---------|
| **Feature Spec** | Define behavior contract (source of truth) | Complete BDD scenarios - technology agnostic |
| **User Story** | Reference and verify | Reference to bounded-contexts + story-specific scenarios |

**BDD Scenario Format**:
```gherkin
# Success Path
Given the login page is displayed
When I enter valid credentials and click Login
Then I should be redirected to the dashboard
And I should see my username in the header

# Error Case
Given a user with email "user@example.com" exists
When I attempt to register with "user@example.com"
Then I should see error "Email already registered"

# Edge Case
Given the file upload limit is 100MB
When I upload a file larger than 100MB
Then I should see error "File exceeds maximum size"
```

### Task Organization by Execution Flow

**Recommended Flow: Test-First Layered** (TDD approach)

```
1. Testing (Write First) → RED phase
2. Backend Implementation → GREEN phase
3. Frontend Implementation → GREEN phase
4. Testing (Make Tests Pass) → GREEN phase completion
5. Refactor → REFACTOR phase
```

**Alternative flows** (choose based on team needs):

| Flow | Order | Best For |
|------|-------|----------|
| **API-First Parallel** | API Contract → Backend + Frontend (parallel) → Tests | Teams working simultaneously |
| **Backend-First** | Backend → Frontend → Tests | When frontend depends heavily on backend |

**Note**: Regardless of flow, always follow TDD within each layer (write test before implementation).

### Task Granularity Rules

- **Tasks should be completable in 1-3 days**
- **Break down large tasks** into smaller subtasks
- **Each task has clear acceptance criteria** (from user story)

Example:
- ❌ Too broad: "Build authentication system"
- ✅ Better (User Story): "As a user, I can login with email/password so that I can access my data"
  - Document: `phase-01-story-02-user-login.md`
  - Tasks include:
    - "Implement JWT token generation endpoint"
    - "Create login form component"
    - "Write unit tests for password hashing"

---

## Step 8: Create development-conventions.md

Define **shared conventions and principles** that apply across all phases.

**CRITICAL: Focus on SHARED conventions only**

The `development-conventions.md` must be **lean and focused**. It contains:
1. **Shared principles** (DDD, self-contained, code quality)
2. **Quick reference links** (docs, R packages, external resources)
3. **Technology stack** (extracted from system architecture document)
4. **Coding conventions summary** (naming, formatting)
5. **Development environment** (how to run servers)

**What NOT to include** (these go in story documents):
- Detailed API patterns (story-specific)
- Database migration details (story-specific)
- Testing strategies (story-specific)
- Common code patterns (belong in story documents)

**CRITICAL: Must include TDD section** (concise, ~10-15 lines):
- Red-Green-Refactor cycle
- Test-first workflow by task type
- Rule: never mark complete with failing tests

### Target Length

~150-250 lines maximum

### What to Include

See **[`references/conventions-template.md`](references/conventions-template.md)** for the complete structure.

### Key Sections

1. **Shared Principles** - DDD, self-contained, code quality, testing principles, **TDD specification**
2. **Quick Reference Links** - Design documents, R packages, SDK references
3. **Technology Stack** - Extracted from system architecture document (see below)
4. **Coding Conventions Summary** - Naming, formatting (brief)
5. **Development Environment** - How to run servers
6. **Important Notes** - Git rules, where to find details
7. **Quick Reference - Project Structure** - Backend/frontend/test directory summary (with link to detailed docs)

---

### Technology Stack Section (CRITICAL: Extract from Source Documents)

**PRINCIPLE**: This skill is **generic and reusable**. Do NOT hardcode specific technologies.

Instead, **extract the technology stack from the system architecture document** (or similar design document) read in Step 2.

#### How to Extract Technology Stack

1. **Locate the tech stack section** in the system architecture document
   - Look for sections titled "Technology Stack", "Tech Stack", "Stack Overview", or similar
   - Often found in architecture or design documents

2. **Parse by categories** - Group technologies by purpose:
   - **Backend**: API framework, ORM, database, version notes
   - **Frontend**: Framework, UI libraries, state management, styling
   - **Build/Package Tools**: Package managers, build tools
   - **Code Quality Tools**: Formatters, linters (group by language)
   - **Testing**: Backend, frontend, and E2E testing frameworks
   - **Infrastructure**: Containerization, reverse proxy, deployment tools
   - **Project-Specific Libraries**: Major libraries unique to this feature

3. **Format concisely** - One line per category with bullet points and descriptive labels where helpful:
   ```markdown
   - **Backend**: {API framework}, {ORM}, {database} {version+}
   - **Frontend**: {Framework}, {UI library}, {state}, {styling}
   - **Build/Package Tools**: {package manager}, {build tool}
   - **Code Quality Tools**: {formatter} (language), {linter} (language)
   - **Testing**: {backend framework}, {frontend framework}, {E2E framework}
   - **Infrastructure**: {containerization}, {reverse proxy}, {deployment}
   - **Project-Specific Libraries**: {library name} (purpose; install notes)
   ```

4. **Add source reference** - Always note where the stack was extracted from:
   ```markdown
   **EXTRACTED FROM**: `{path to architecture document}`
   ```

5. **NO hardcoded examples** - The template uses placeholders only. Always extract actual values from the feature's documentation.

#### Generic Pattern for Any Project

For features **without** a dedicated tech stack section:
- Look for `package.json`, `requirements.txt`, `pom.xml`, `go.mod`, etc.
- Look for CI/CD files (`.github/workflows/`, `Dockerfile`, `docker-compose.yml`)
- Look for README sections listing dependencies or requirements
- Extract common patterns and group by category

The skill should work for **any feature**, not just dataflow.

---

## Step 9: Create development-progress.md

Create a progress tracking document that summarizes status across all user stories.

**CRITICAL: Self-Contained Principle**

The progress document must include all context needed to track development:

- **Phase list with descriptions** - What each phase does
- **Story summary per phase** - List of stories with their status
- **Completion criteria** - What "done" means for each story

The progress tracker is the **single source of truth** for feature status.

**Note**: Detailed task lists live in each story document. The progress document provides summary views.

### Structure (Minimal Story-Based Tracking)

See **[`references/development-progress-template.md`](references/development-progress-template.md)** for the template.

**Progress Summary** - minimal columns:

```markdown
| Phase | Status | Stories |
|-------|--------|---------|
| 01 | ⚪ Not Started | 0/3 |
| 02 | ✅ Complete | 2/2 |
```

**Column meanings**:
- **Status**: Overall phase status (derived from stories)
- **Stories**: Count of completed stories (e.g., "2/3" = 2 of 3 complete)

**All Stories View** (main tracking table):

```markdown
| Story File | Title | Status | Notes |
|------------|-------|--------|-------|
| `phase-01-story-01-*.md` | User Registration | ✅ Complete | |
| `phase-01-story-02-*.md` | Email Verification | 🔄 In Progress | |
| `phase-01-story-03-*.md` | User Login | ⚪ Not Started | |
```

**Each Phase section** shows:
1. Phase status with story completion count
2. Story table for that phase only

```markdown
## Phase 01: {Phase Name}

**Status**: 🔄 In Progress (1/3 stories)

| Story File | Title | Status | Notes |
|------------|-------|--------|-------|
| `phase-01-story-01-*.md` | User Registration | ✅ Complete | |
| `phase-01-story-02-*.md` | Email Verification | 🔄 In Progress | |
| `phase-01-story-03-*.md` | User Login | ⚪ Not Started | |
```

> **Note**: Detailed task breakdowns (Backend, Frontend, Testing layers) live in each story document. The progress document provides simplified status tracking with just one overall status per story.

### Initial State

All phases and stories should start as **⚪ Not Started**:

```markdown
## Progress Summary

| Phase | Status | Stories |
|-------|--------|---------|
| 01 | ⚪ Not Started | 0/3 |
| 02 | ⚪ Not Started | 0/2 |
```

---

## Reference Templates

This skill includes reference templates for consistent document structure:

| Reference | Purpose | When to Read |
|-----------|---------|--------------|
| `story-document-template.md` | Story document structure | When creating story documents |
| `conventions-template.md` | Conventions document structure | When creating development-conventions.md |
| `development-progress-template.md` | Progress document structure | When creating development-progress.md |

**Always read these templates before creating documents** to ensure consistency.

---

## Output Location

All documents are created in a **wave-specific subdirectory** with **flat story documents**:

```
development/
├── {wave-name}/
│   ├── phase-01-story-01-{name}.md
│   ├── phase-01-story-02-{name}.md
│   ├── phase-01-story-03-{name}.md
│   ├── phase-02-story-01-{name}.md
│   ├── phase-02-story-02-{name}.md
│   ├── ...
│   ├── development-conventions.md
│   └── development-progress.md
```

**Example:**
```
development/
├── user-auth-oauth/
│   ├── phase-01-story-01-user-registration.md
│   ├── phase-01-story-02-email-verification.md
│   ├── phase-01-story-03-user-login.md
│   ├── phase-02-story-01-oauth-google.md
│   ├── phase-02-story-02-oauth-github.md
│   ├── development-conventions.md
│   └── development-progress.md
```

**Naming Format**: `phase-{NN}-story-{MM}-{kebab-case-title}.md`
- `{NN}`: Two-digit phase number (01, 02, ..., 10, 11, ...)
- `{MM}`: Two-digit story number (01, 02, ..., 10, 11, ...)

---

## Completion Checklist

Before finishing, verify:

- [ ] PREREQUISITE: bounded-contexts/{feature}.md exists and is validated
- [ ] Step 1: Preliminary scope questions asked
- [ ] Step 2: Design documents read (4 sources: bounded-contexts + application-design + ui-pages + bounded-contexts, + existing code for brownfield)
- [ ] Step 3: Interactive session completed with user
- [ ] Step 4: Wave name determined and directory created
- [ ] Step 5: Phase count and user stories determined
- [ ] Step 6: Preview presented to user
- [ ] Step 6: User approved the plan (Generate)
- [ ] Wave name is descriptive and in kebab-case
- [ ] Wave directory created: `development/{wave-name}/`
- [ ] Phase count matches feature complexity
- [ ] Each phase has descriptive name
- [ ] User stories defined per phase with clear acceptance criteria
- [ ] Each user story is a self-contained document (`phase-{NN}-story-{MM}-{title}.md`)
- [ ] **Each story includes BDD scenarios**: Given/When/Then format covering success/error/edge cases
- [ ] **Each story includes task breakdown**: Organized by execution flow (Testing → Backend → Frontend → Fix Tests → Refactor)
- [ ] **Each story follows TDD**: Testing tasks FIRST, then implementation tasks
- [ ] Task definitions are NOT prescriptive (no source code, just task descriptions)
- [ ] development-conventions.md includes **TDD section** (Red-Green-Refactor cycle, test-first workflow)
- [ ] Tasks are granular (1-3 day completion)
- [ ] development-conventions.md covers shared principles and patterns
- [ ] development-progress.md has User Story summary tables
- [ ] All files created in `development/{wave-name}/`

## Progress Tracking Guidelines

When updating development-progress.md during implementation, follow these rules:

### Status Meanings

| Status | Symbol | When to Use |
|--------|--------|-------------|
| Not Started | ⚪ | Initial state |
| In Progress | 🔄 | Currently being worked on |
| Partial | ⚠️ | Work done but loose ends remain (tests failing, bugs, skipped tests) |
| Complete | ✅ | Fully complete with ALL tests passing |
| Blocked | ⚠️ | Cannot proceed due to blocker |
| Failed | ❌ | Task failed |

### Critical Rule: NEVER Mark Partial Work as Complete

**A task is ✅ Complete ONLY when:**
1. Implementation is done
2. ALL tests pass (not just some)
3. No known bugs
4. Acceptance criteria fully met

**Use ⚠️ Partial when:**
- Tests written but failing (e.g., "4/13 passing, fixture fixes needed")
- Tests skipped/deferred (e.g., "Frontend tests skipped: extensive mocking required")
- Known bugs exist
- Documentation incomplete

### Example

```markdown
### Testing

| Test | Status | Notes |
|------|--------|-------|
| Unit tests (backend - pytest) | ✅ Complete | 19 tests passed |
| Integration tests (API) | ⚠️ Partial | Tests written, 4/13 passing (auth tests pass, data tests need fixture fixes) |
| E2E tests (Playwright) | ⚪ Not Started | Phase 0 E2E verified; Phase 2 follows same patterns |

**Testing Status**: ⚠️ Partial (loose end: integration test fixtures)
```

This honesty prevents technical debt accumulation and provides accurate feature status.

---

## Example Usage

### Simple Project

**User input**: "Build a simple blog API"

**Planning**:
- 2 phases sufficient
- Phase 1: Foundation (FastAPI setup, Postgres, blog posts CRUD)
  - `phase-01-story-01-view-blog-posts.md` - "As a reader, I can view blog posts so that I can read content"
  - `phase-01-story-02-create-blog-post.md` - "As an author, I can create posts so that I can publish content"
  - `phase-01-story-03-edit-delete-post.md` - "As an author, I can edit/delete posts so that I can manage my content"
- Phase 2: Polish (comments, search, testing)
  - `phase-02-story-01-comment-on-posts.md` - "As a reader, I can comment on posts so that I can engage with content"
  - `phase-02-story-02-search-posts.md` - "As a reader, I can search posts so that I can find specific content"

**Each story document includes**:
- User Story, Acceptance Criteria, BDD Scenarios
- Tasks organized by execution flow: Testing → Backend → Frontend → Fix Tests → Refactor
- Technical Reference (points to bounded-contexts for API contracts, data model, etc.)

### Medium Project

**User input**: "Create a task management web app with user accounts"

**Planning**:
- 3 phases needed
- Phase 1: Foundation
  - `phase-01-story-01-user-registration.md` - "As a user, I can register so that I can create an account"
  - `phase-01-story-02-user-login.md` - "As a user, I can login so that I can access my account"
  - `phase-01-story-03-create-project.md` - "As a user, I can create projects so that I can organize my work"
- Phase 2: Core Features
  - `phase-02-story-01-create-task.md` - "As a user, I can create tasks so that I can track work items"
  - `phase-02-story-02-assign-task.md` - "As a user, I can assign tasks so that I can delegate work"
  - `phase-02-story-03-task-due-dates.md` - "As a user, I can set due dates so that I can manage deadlines"
- Phase 3: Polish
  - `phase-03-story-01-notifications.md` - "As a user, I can receive notifications so that I stay updated"
  - `phase-03-story-02-search-tasks.md` - "As a user, I can search tasks so that I can find items"

**Each story document includes**:
- User Story, Acceptance Criteria, BDD Scenarios
- Tasks organized by execution flow: Testing → Backend → Frontend → Fix Tests → Refactor
- Technical Reference (points to bounded-contexts for API contracts, data model, etc.)

### Complex Project

**User input**: "Build an e-commerce platform with payment processing"

**Planning**:
- 5+ phases needed
- Phase 1: Foundation
  - `phase-01-story-01-customer-registration.md` - "As a customer, I can register so that I can create an account"
  - `phase-01-story-02-customer-login.md` - "As a customer, I can login so that I can access my account"
  - `phase-01-story-03-product-catalog.md` - "As an admin, I can manage products so that customers can browse"
- Phase 2: Shopping
  - `phase-02-story-01-browse-products.md` - "As a customer, I can browse products so that I can find items"
  - `phase-02-story-02-shopping-cart.md` - "As a customer, I can add items to cart so that I can prepare for checkout"
- Phase 3: Payments
  - `phase-03-story-01-stripe-checkout.md` - "As a customer, I can checkout with Stripe so that I can complete purchase"
  - `phase-03-story-02-order-confirmation.md` - "As a customer, I can view order confirmation so that I know it's placed"
- Phase 4: Accounts
  - `phase-04-story-01-order-history.md` - "As a customer, I can view order history so that I can track purchases"
  - `phase-04-story-02-refunds.md` - "As an admin, I can process refunds so that I can handle returns"
- Phase 5: Testing & Deployment

**Each story document includes**:
- User Story, Acceptance Criteria, BDD Scenarios
- Tasks organized by execution flow: Testing → Backend → Frontend → Fix Tests → Refactor
- Technical Reference (points to bounded-contexts for API contracts, data model, etc.)

---

## Project Lifecycle

**Active**: `development/{wave-name}/` — Work in progress

**Structure during development**:
```
development/{wave-name}/
├── phase-01-story-01-*.md
├── phase-01-story-02-*.md
├── phase-02-story-01-*.md
├── ...
├── development-conventions.md
└── development-progress.md
```

**Archive pattern**: `history/Archive-{description}-{timestamp}/`

**When complete**, use `material-archiver` to move:
```
development/{wave-name}/  →  history/Archive-{description}-{timestamp}/
```

**Example**:
```
development/user-auth-oauth/  →  history/Archive-User-Auth-OAuth-20260123-143052/
```
